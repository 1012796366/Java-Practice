# 第六题输出
输出 sum=-100
<br>分析：
<br>所包含的类 B 提供了三个成员函数，分别为 setX(int x)，setY(int y)，getXYsum()
<br>setX() 并没有修改实例成员 x 的值，这是因为它的参数 x 覆盖了实例成员 x，执行 x = x 时只会对参数的 x 进行修改，而不会对实例成员有修改。
<br>setY() 的参数 y 虽然覆盖了实例成员 y 的值，但是它在执行赋值时，明确指明了对象，即 this.y = y 而非 y = y，因此可以修改实例成员的值。
<br>而在主函数执行后，对象 b 的实例成员 x 仍然为 100，而 y 替换为了 -200，因此最后显示的是 sum=-100
# 第七题输出
输出 777
<br>分析：
<br>Java 没有严格意义上的引用传递，既然如此，那么在执行 add(b) 时，b 的实例成员不应该被修改，然而根据实际的表现来看，b 所对应的对象的实例成员已经修改。
<br>关键在于 add(b) 的参数传递方式，如果 b 是基础类型，则传递的只是拷贝，而非引用，add() 中的修改不会影响到 b 的值
<br>而当 b 为实例对象时，传递方式实际上仍然是值传递，然而传递的不是对象拷贝，而是对象地址的拷贝。
<br>因此，b 被传入 add() 后，add() 就拿到了 b 指向的地址，因此也就可以修改掉 b 所对应的实例对象的值了。
<br>传递实例对象就像是把自己家的备用钥匙给邻居一样，拷贝的不是家（对象），而是钥匙（地址），邻居拿到钥匙后就可以对我家修改（函数通过地址修改对象），而我也会受到影响，看上去就像是按引用传递，实际上并不是严格意义上的按引用传递。
<br>但是需要注意 String 对象的传递——

```java
public class Test {
    public static void main(String[] args) {
        String name = "Name in Main\n";
        modify();
        System.out.print(name);
    }

    public static void modify(String name) {
        name = "Name in Modify\n";
        System.out.print(name);
    }
}
```
上述代码传递 String 对象时确实是按值传递，并且是将地址传过去，但是在 Java 中，仅仅是 name = "..." 并不意味着修改所指向地址上存储的字符串的值，而只是改变了地址指向的位置，因此不会修改掉原来的 String 对象所指向地址上存储的字符串。
# 第八题输出
输出 27
<br>分析：
<br>sum 有修饰符 static，因而它不是实例成员，而是静态成员，任何实例成员都会影响它的值。
<br>而 getSum() 函数则是求 1 ~ n 所有数相加起来的和，同时每一次都会将值加到 sum 上。
<br>例如，当 n = 3 时，sum 的值将被修改为 sum + 6，而当 n = 5 时，sum 的值将被修改为 sum + 15。
<br>因此 b1 调用 getSum() 函数时 sum 的值变为 6，随后 b2 调用 getSum() 之后，sum值变为 6 + 15 也就是 21，相加得到27，因此输出为 27。