# 第六题输出
输出 sum=-100
<br>分析：
<br>所包含的类 B 提供了三个成员函数，分别为 setX(int x)，setY(int y)，getXYsum()
<br>setX() 并没有修改实例成员 x 的值，这是因为它的参数 x 覆盖了实例成员 x，执行 x = x 时只会对参数的 x 进行修改，而不会对实例成员有修改。
<br>setY() 的参数 y 虽然覆盖了实例成员 y 的值，但是它在执行赋值时，明确指明了对象，即 this.y = y 而非 y = y，因此可以修改实例成员的值。
<br>而在主函数执行后，对象 b 的实例成员 x 仍然为 100，而 y 替换为了 -200，因此最后显示的是 sum=-100
# 第七题输出
输出 777
<br>分析：
<br>Java 没有引用传递，既然如此，那么在执行 add(b) 时，b 的实例成员不应该被修改，然而根据实际的表现来看，b 所对应的对象的实例成员已经修改。
<br>关键在于 add(b) 的参数传递方式，如果 b 是基础类型，则传递的只是拷贝，而非引用，add() 中的修改不会影响到 b 的值
<br>而当 b 为实例对象时，传递方式实际上仍然是值传递，然而传递的不是对象拷贝，而是对象地址的拷贝。
<br>因此，b 被传入 add() 后，add()就拿到了 b 上存储的地址，因此也就可以修改掉 b 所对应的实例对象的值了。
<br>就像是给了邻居自己家的备用钥匙一样，拷贝的不是家，而是钥匙。
# 第八题输出
输出 27
<br>分析：
<br>sum 有修饰符 static，因而它不是实例成员，而是静态成员，任何实例成员都会影响它的值。
<br>而 getSum() 函数则是求 1 ~ n 所有数相加起来的和，同时每一次都会将值加到 sum 上。
<br>例如，当 n = 3 时，sum 的值将被修改为 sum + 6，而当 n = 5 时，sum 的值将被修改为 sum + 15。
<br>因此 b1 调用 getSum() 函数时 sum 的值变为 6，随后 b2 调用 getSum() 之后，sum值变为 6 + 15 也就是 21，相加得到27，因此输出为27。